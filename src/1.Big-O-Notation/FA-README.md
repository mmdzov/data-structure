# Big-O-Notation

یک نماد ریاضی است که برای توصیف پیچیدگی زمانی الگوریتم ها استفاده میشود و راهی برای اندازه گیری کارایی الگوریتم با محاسبه زمان و مقدار حافظه مورد نیاز جهت اجرای الگوریتم برای مقدار ورودی است

توابع را بر اساس نرخ رشد آنها طبقه بندی می کند و برای اندازه گیری و مقایسه بدترین سناریوهای الگوریتم ها درنظر گرفته میشود

#### بطور خلاصه نماد Big-O برای اندازه گیری پیچیدگی زمانی بدترین حالت یک الگوریتم است

همچنین در مقایسه الگوریتم های مختلف و تعیین اینکه کدام یک کارآمدتر است مفید است

وقتی الگوریتمی را پیاده سازی می کنید با استفاده از Big-O می توانید سرعت و کارایی الگوریتم خود را بفهمید

نمونه Big-O های رایج را در تصویر زیر می توانید مشاهده کنید

<div align="center">
  <img src="https://github.com/mmdzov/data-structure/blob/main/assets/1.big-o.png" alt="Big-O" />
  <div>1.Big-o</div>
</div>

در این نماد حرف n تعداد ورودی را نشان می ده

اگر پیچیدگی الگوریتم O(1) باشد یعنی جدا از مقدار ورودی زمان ثابتی را طی میکند. مهم نیست چه مقداری داده باشیم 10 یا 1000 هردو زمان یکسانی را تا اتمام عملیات طی میکنند.

بعنوان یک نمونه مثال از O(1) می توان به عملیات های push() و pop() برروی یک آرایه اشاره کرد همچنین دریافت مقدار آرایه با استفاده از شاخص یاایندکس را شامل میشود

#

اگر پیچیدگی الگوریتم O(n) باشد یعنی زمان بصورت خطی جلو میرود. 

یک حلقه باعث رشد خطی میشود به علت اینکه مقدار ورودی هرچقدر که باشد به همان اندازه زمان طول میکشد تا عملیات تکمیل شود.

یک O(n) مشابه زیر است

```javascript
function linear(n: number) {
  for (let i = 0; i < n; i++) {
    console.log(i);
  }
}
```

حال اگر n هر مقداری باشد به همان اندازه زمان صرف میشود زیرا میان زمان تکمیل و اندازه داده ، رابطه یک-به-یک وجود دارد.


#

اگر پیچیدگی برابر با O(N²) باشد بنابراین یک زمان درجه 2 یا مربعی محسوب میشود.

یک O(N²) مشابه زیر است

```javascript
function quadratic(n: number) {
  for (let i = 0; i < n; i++) {
    for (let t = i; t < n; t++) {
        console.log(t);
    }
  }
}
```

> آیا نیاز به یافتن یک جفت منطبق برای هر آیتم در یک آرایه دارید؟ قرار دادن یک حلقه در داخل یک حلقه راهی عالی برای تبدیل یک آرایه از 1000 مورد به یک میلیون جستجوی عملیاتی است که مرورگر شما را مسدود می کند. همیشه بهتر است 2000 عملیات روی دو حلقه جداگانه انجام شود تا یک میلیون عملیات با دو حلقه تو در تو. digitalocean


#

اگر پیچیدگی برابر با O(n³) باشد بنابراین یک زمان درجه 3 یا مکعبی محسوب میشود.

یک O(n³) مشابه زیر است

```javascript
function cubic(n: number) {
  for (let i = 0; i < n; i++) {
    for (let t = i; t < n; t++) {
        for (let s = t; s < n; s++) {
            console.log(s);
        }
    }
  }
}
```

#

اگر پیچیدگی لگاریتمی یا O(log N) باشد می تواند اندازه داده های ورودی را در هر مرحله کاهش دهد درنتیجه با افزایش اندازه ورودی، زمان اجرا با سرعت بسیار کمتری نسبت به الگوریتم هایی با پیچیدگی O(n) و بالاتر(مانند مربعی و مکعبی) مصرف میشود
اینگونه الگوریتم با پیچیدگی O(log N) برای داده های بزرگ کارآمدتر می باشند.

ساختارهای داده ای از جمله Binary Search Trees (BST) , Hash Tables , Stacks 
از O(log N) استفاده می کنند.

نمونه زیر یک مثال از پیچیدگی لگاریتمی O(log N) با پایه 2 است.

```javascript
function log(n: number) {
    for(var i = 2; i <= n; i = i * 2) {
        console.log(i)
    }
}
```
