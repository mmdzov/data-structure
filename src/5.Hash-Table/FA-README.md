# جدول هش

جدول هش نوعی ساختار داده است که این امکان را میدهد تا بتوان لیستی از مقادیر جفت شده تحت عنوان کلید/مقدار ایجاد کرد و با استفاده از کلید عملیات درج و حذف را انجام داد.

جدول هش با استفاده از تابع هش کلید را به عدد صحیح تبدیل می کند و بر اساس ایندکس جفت کلید/مقدار در موقعیت قرار می گیرند.

# کاربردها

- آرایه های انجمنی
- Database indexing
- جستجوی سریع
- شبکه های لایه ای
- برنامه نویسی چند الگوریتمی
- داده های منحصر به فرد
- Caching
- الگوریتم های کریپتوگرافی

# مزایا

- همگام سازی بهتری نسبت سایر ساختارهای داده ارائه می دهد.
- کارآمدتر از درخت های جستجو یا سایر ساختارهای داده هستند.
- بطور متوسط زمان ثابتی برای عملیات های درج ، حذف و جستجو ارائه می کند.
- استفاده آسان.
- بازیابی و دستکاری داده ها با سرعت بالا.
- معمولا بطور خودکار اندازه خود را تغییر می دهد.

# معایب

- زمانی که برخوردهای زیادی وجود داشته باشد ناکارآمد است.
- برای مجموعه بزرگی از کلیدهای احتمالی از برخورد هش جلوگیری نمی شود.
- به مقادیر تهی اجازه نمی دهد
- ظرفیت محدودی دارند و درنهایت پر خواهند شد.
- پیاده سازی آن می تواند پیچیده باشد.
- ترتیب عناصر را حفظ نمی کنند و بازیابی عناصر در ترتیب خاص دشوار می شود.

# رسیدگی به برخوردها

در بالا ، در رابطه با وظیفه تابع هش توضیح داده شده. حالا تصور کنید که الگوریتم هش در این تابه به گونه ای باشد که باعث شود برای دو الی چند جفت کلید/مقدار یک شاخص درنظر گرفته شود.

بعنوان مثال یک کلید به نام "foo" وجود دارد و تابع هش بصورت زیر است.

```javascript
let size = 40;

function hash(key) {
  return key.toString().length % size;
}
```

در بالا متغیر size برابر با طول جدول هش می باشد که در ابتدا درنظر گرفته شده.

حالا تصمیم بر این است که کلید "foo" به عدد صحیح تبدیل شود

```javascript
let key = "foo";

let index = hash(key);

console.log(index); // 3
```

حالا تصور کنید که کلید "bar" قرار است یک شاخصی تعیین کند

```javascript
let key = "bar";

let index = hash(key);

console.log(index); // 3
```

هر دو شاخص 3 هستند بنابراین ممکن است در جای گذاری کلید/مقدار برخورد به وجود بیاید.

برای جلوگیری از این برخوردها روش های متعددی وجود دارد که در زیر به چند مورد از آنها اشاره شده.

1. Linear probing
   در این استراتژی اگر شاخص از قبل پر شده باشد به موقعیت بعدی می روید باید به گونه ای تنظیم شود که موقعیت بعدی خالی باشد اگر اشتباه تنظیم شود ممکن است موقعیت های زیادی را بگردید که در این روش پیچیدگی زمانی به O(n) نزدیک تر می شود و به سمت ناکارآمدی می رود.

2. Separate Chaining
   در این استراتژی معمولا از لیست های پیوندی یا درخت برای هر شاخص استفاده می شود. درصورتی که شاخص موردنظر پر شده باشد به گره فرزند آن نفوذ می کنیم تا به آخرین گره برسیم. به این روش زنجیره سازی می گویند که به ما این امکان را میدهد چندین جفت کلید/مقدار را در یک شاخص ذخیره کنیم. این استراتژی عملکردها را افزایش می دهد اما از لحاظ فضا می تواند پرهزینه نیز باشد.

3. Open addressing
   در این استراتژی اگر شاخص مدنظر پر باشد بنابراین به شاخص بعد می رویم تا اولین شاخص خالی را پیدا کنیم و جفت کلید/مقدار را درونش قرار دهیم پیچیدگی زمانی در این روش O(n) می باشد.

# پیچیدگی ها

| set  | get  | delete |
| :--: | :--: | :----: |
| O(1) | O(1) |  O(1)  |

بدترین شرایط پیچیدگی هرکدام ممکن است O(n) باشد
