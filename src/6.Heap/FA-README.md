# Heap (Min heap and Max heap)

یک نوع ساختار داده درختی دودویی است که دارای ویژگی های زیر است.

1. ساختار بصورت CBT یا همان Complete Binary Tree می باشد
   در این حالت باید گره های هر سطر کامل بشود بجز احتمالا آخرین لایه.

گره ها از چپ به راست پر میشوند بعنوان مثال ما مقدار A, B, C, D, E, F را داریم که میخواهیم در یک درخت CBT نمایش بدیم.

```
        A
   B         C
D   E     F

```

مشاهده میکنید که از چپ به راست مقدار دهی صورت گرفته و این یک درخت CBT است.
حالا E و D فرزند B هستند و B فرزند A می باشد. همینطور برای F و C چنین چیزی صدق میکند.

مثال زیر هم درست است

```
         A
   B         C
 D   E     F   G

```

مثال درخت زیر CBT نیست:

```
        A
   B        C
D              E
```

چون در B حداکثر تعداد گره ها درج نکردیم که به سراغ C رفتیم.... درخت زیر هم CBT نیست:

```
        A
   B         C
D          E   F
```

مگه نگفتیم هر سطر از چپ به راست پیش میریم؟ پس چرا هنوز گره های زیرمجموعه B کامل پر نشده رفتیم سراغ C.... این یک درخت باینری کامل (CBT) نیست.

2. هر گره Heap property را برآورده میکند.

اگر A والد B باشد بنابراین:

در Max Heap باید A بزرگ تر مساوی B باشد که با علامت زیر نمایش داده میشود
key(A) ≥ key(B)

در Min Heap باید A کوچک تر مساوی B باشد که با علامت زیر نمایش داده میشود.
key(A) ≤ key(B)

برای درک بهتر می توانید Heap را یک آرایه تصور کنید

به علت دودویی بودن heap ها ترتیب اعداد کمی متفاوت است به تصویر زیر توجه کنید

<div align="center">
  <img src="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/heap/images/array-representation.jpeg" alt="1.Stack" />
  <div>1.Heap</div>
</div>

آرایه را مشاهده کنید، ترتیب آرایه اولیه اصلا مهم نیست ما با نشانگرا کار داریم توجه کنید که هر عنصر دو نشانگر به عناصر خالی بعدش دارد که 0 و 1 را نشان میدهد و این دودویی بودن heap رو ثابت میکنه.

حالا بیایم آرایه زیر رو تشریح کنیم تا درک نحوه کار heap ساده تر بشه:

```
[4, 6, 3, 12, 1, 88]
```

من میخوام max heap روی آرایه بالا انجام شه و سه عنصر اول رو ابتدا میارم وسط بنابراین می نویسم :

```
       4
   6      3
```

چون 6 از 4 بزرگ تره جاشون عوض میشه و 6 سواپ( جا به جا ) میشه به بالا.

```
        6
    4      3
12

```

در بالا 12 چون بزرگ تر از 4 هست سواپ میشه، بزرگ تر از 6 هم هست بنابراین بازم سواپ میشه.

```
            12
      6           3
   4    1      88

```

حالا 88 بزرگ تر از 3 هست سواپ میشه و حتی بزرگ تر از 12 هست بازم سواپ میشه و در نهایت نتیجه آرایه بالا، حالت زیر است :

```
           88
      6         12
   4    1     3

[ 88, 6, 12, 4, 1, 3 ]
```

همچنین برای min heap به همین صورت ولی بلعکس یعنی از کم به زیاد می باشد همانند زیر:

```
            1
     3            4
  12   6       88

‌[ 1, 3, 4, 12, 6, 88 ]
```

میتونید با دید ریاضی هم به این موضوع نگاه کنید که این دید مهم تره چون شما قراره با استفاده از همین دیدگاه یک heap ایجاد و مدیریت کنید.

دریافت ایندکس فرزند سمت چپ
2 _ parentIndex + 1
دریافت ایندکس فرزند سمت راست
2 _ parentIndex + 2
دریافت ایندکس پرنت
Math.floor((i - 1) / 2)
کلمه i برابر با ایندکس فرزند هست

آرایه زیر رو درنظر بگیرید

```
[4, 6, 3, 12, 1, 88]
```

حالا ما میخواهیم با دیدگاه ریاضی این رو min heap کنیم.

```
    4
 6     3
```

عدد 3 بعنوان یک مقدار جدید از عدد 4 کوچیک تره پس باید سواپ بشه به بالا بنابراین عدد 3 آخرین مقدار آرایه heap می باشد درنتیجه ما به واسطه همین مقدار آخر میایم به روش زیر ایندکس پرنتش رو پیدا میکنیم

`Math.floor((childIndex - 1) / 2)`

سپس آنها را جا به جا می کنیم تا زمانی که بسته به نوع min یا max هیپ بودن، مقدار پرنت کوچیک تر مساوی یا بزرگ تر مساوی فرزند باشد سواپ به بالا انجام شود. میتونید توی حلقه while انجامش بدید.

```
            3
       6        4
   12    1

```

در بالا باید مقدار 1 حداقل دو پله به بالا سواپ شود چون از 6 و 3 کوچک تر است.

```
           1
    3             4
 12   6       88
```

مراحل ایجاد interface هیپ

1. ایجاد یک کلید جدید در هپ
2. حذف کلید از هپ

مراحل ایجاد یک کلید جدید در هپ

1. ایجاد یک آرایه
2. پوش ( push ) کردن کلید در اون آرایه
3. تنظیم موقعیت کلید در heap

در مرحله 3 همانطور که بالا هم گفتم باید تا جایی که میشه مقدار کلید رو بسته به نوع min یا max هیپ بودن به سطوح بالاتر رسوند.

حذف کلید :
درصورتی که کلیدی حذف شود آخرین کلید درون لیست جایش را میگیرد و سپس تلاش میشود تا کلید جا گرفته بسته به نوع min یا max هیپ بودن به سطوح پایین سواپ شود بطور مثال آرایه زیر را فرض کنید

```
[15, 8, 32, 13]
```

من میخوام روی این آرایه max heap انجام بدم.

```
         32
    13        15
 8

```

حالا مقدار 32 رو حذف میکنم میشه نتیجه زیر

```
          8
    13        15

```

و اما حالا باید تلاش بشه که سواپ داون انجام شه خب 15 از 8 بزرگ تره بنابراین 8 میاد جای 15

```
          15
    13         8

```

علت اینه که وقتی 8 اومده جای گره حذف شده رو گرفته باید مقایسه کنه که کدوم از گره های زیرمجموعش بزرگ تره تا باهاش جایگزین بشه.
توی min heap دقیقا این برعکسه... باید ببینه کدوم از گره های زیرمجموعش کوچیک تره تا جایگزینش بشه و تمام اینها تا زمانی ادامه داره که بسته به نوع min یا max هیپ بودن، بزرگ تر مساوی یا کوچیک تر مساوی تر از اون عدد نباشه در مثال بالا 8 تا زمانی میاد پایین که بزرگ تر از اون بین دوتا گره زیر مجموعه وجود نداشته باشه.

هیپ میتونه بعنوان یک صف هوشمندتری باشه که ترتیب مقادیرش بر اساس اهمیته.

هیپ ها نهایتا مجاز هستند 2 فرزند داشته باشند
